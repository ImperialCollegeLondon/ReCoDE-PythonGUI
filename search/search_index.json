{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ReCoDE_PythonGUI A multi-channel GUI for real-time data display and analysis In this course, you will learn how to create a GUI program to display and analyze data in real-time with Python. The GUI program is designed to display and analyze data from a file. The GUI program is also designed to display data from a data acquisition system through serial port communication. The GUI program is developed using dearpygui, a GPU-based Python GUI framework. By the end of this course, you will be able to design a GUI program looks like the above picture, which can display data from a file or a data acquisition system in real-time. You will also be able to select the file to display, select the channels to display, change the color of the lines, and start, stop, and pause the display. You will also learn how to add data analysis functions to the GUI program and display analysis results in real-time. Before we start Here is some useful links from Diego Alonso \u00c1lvarez telling you how important GUI is for research software. - GUIs for research software: Why are they relevant? (part one) - GUIs for research software: Why are they relevant? (part two) The GUI framework we use in this course is dearpygui, here is a link to the domentation of dearpygui Dearpygui documentation . Dearpygui is chosen for its ability to create a GUI with a few lines of code. It is also a very powerful GUI framework that can be used to create a complex GUI. Most importantly, it supports GPU rendering and multi-threading, which makes it very fast and responsive. Introduction to GUI design for real-time data display and analysis What is GUI? GUI stands for Graphical User Interface. It is a type of user interface that allows users to interact with electronic devices through graphical icons and visual indicators. GUIs were introduced in reaction to the perceived steep learning curve of command-line interfaces (CLIs), which require commands to be typed on the keyboard. The actions in a GUI are usually performed through direct manipulation of the graphical elements. The graphical elements include but not limited to windows, menus, buttons, scrollbars, icons, etc. Why do we need GUI? GUIs are widely used in many applications including operating systems, web browsers, office suites, email programs, etc. GUIs are also used in scientific applications, including data acquisition, data analysis, and data visualization. Their utilization in scientific applications stems from their user-friendly nature, facilitating the creation of intuitive interfaces tailored to scientific tasks. GUI frameworks There are many GUI frameworks available for Python. Some of the popular GUI frameworks include Tkinter, PyQt, PySide, wxPython, Kivy and so on. Different GUI frameworks have different ways to create a GUI. In this course, we will use dearpygui as the GUI framework. Dearpygui is chosen for its ability to create a GUI with a few lines of code. It is also a very powerful GUI framework that can be used to create a complex GUI. Most importantly, it supports GPU rendering and multi-threading, which makes it very fast and responsive. There are plenty of GUI software developed by dearpygui. You can find them in the dearpygui showcase . Structure of this course Day 1: Develop familiarity with frameworks and key components for GUI design. Contents: You will be provided with sample codes to familiarize commonly used GUI widgets. You can design whatever you want using provided widgets. (Sample data will be provided) * Outcomes: You will be able to design a GUI with different kinds of widgets including buttons, text boxes, figures and so on. Day 2: Design a GUI to dynamically display data with single channel. Contents: You will be provided a template with sample modularized codes to illustrate how to add a figure on GUI and make it work. You will also learn how to display data from a file with single channel. Outcomes: You will learn how to update data in a plot widget and be able to design a GUI to display data with single channel. Day 3: Design a GUI to dynamically display data with multiple channels. Contents: You will extend the work in step 2 by referring to another template provided to add two more channles. You will learn how to add multiple figures on GUI and make them work. You will also learn how to display data from a file with multiple channels. Outcomes: You will gain an understanding of tags in dearpygui and be able to update different widgets according to their tags. You will also be able to design a GUI to display data with multiple channels. Day 4: Design a GUI with control panel to control the display. Contents: You will be provided a new template with modularized functions and control widgets as well as directive instructions for adding control widgets used in GUI design. Four control functions will be provided as examples, including select file to display, start, stop and pause the display, select channels to be displayed, and change the color of lines. Outcomes: You will have an understanding of the interactions between different widgets, taking inputs from users and updating widgets accordingly. Day 5: Extension: Serial Port Communication Contents: You will be provided a new template with modularized functions and control widgets to display data from a data acquisition system through serial port communication. You will learn how to display data from a real-time data acquisition system with serial communication. Outcomes: You will gain basic and necessary knowledge on how to use serial port communication with Python. You will also be able to design a GUI that displays data from a data acquisition system in real-time though serial port communication. Preparations Software Python 3.9.7 VisualStudio Code (newest version) Python packages that need to be installed will be introduced in corresponding sections. You will use virual serial port emulator to and a serial port monitor for Day 5. An instruction will be provided in Day 5. Hardware A computer with Windows 10 or Windows 11 operating system You can use a computer with Mac/Linux operating system. However, the virtual serial port emulator for day 5 only supports Windows operating system. Data We are going to use data from the CHARIS database. The CHARIS database contains multi-channel recordings of ECG, arterial blood pressure (ABP), and intracranial pressure (ICP) of patients diagnosed with traumatic brain injury (TBI). As the full dataset is huge, we will only use two of them in this course. Data are stored in Data folder. You should put the data file you want to read in this folder. You can then access the data file by setting the path to Data folder. For example, you can use the following code to read the data file charis4.dat . import numpy as np filename = 'Data/charis4.dat' datafile = open ( filename , 'rb' ) dtype = np . dtype ( 'int16' ) data = np . fromfile ( datafile , dtype ) The full dataset can be downloaded from CHARIS database . Best practice notes Debugging GUI codes is different from traditional code. Have the structure of GUI program in mind. You are placing widgets on a planar canvas. This helps to find missing widgets as they can be blocked by others and determine the relative location of the widgets. Always keep in mind that there still exists CLI when you design GUI, try to print essential variables for debugging. Unless you enable multithreading, your codes run in serial. If your data processing codes are time-consuming, the GUI will be blocked. Assign meaningful names to each widget. For example, you can name a button as start_button , a text box as file_path_textbox , and a figure as data_figure . This helps to find the widget you want to update. Compared with displaying data statically, you should have an understanding of sliding window when you dynamically display data. Always assume the users know nothing about how to use your program. For example, they can start running the progran without selecting a file. You can avoid this by disable the start button unless a file is selected.","title":"Home"},{"location":"#recode_pythongui","text":"","title":"ReCoDE_PythonGUI"},{"location":"#a-multi-channel-gui-for-real-time-data-display-and-analysis","text":"In this course, you will learn how to create a GUI program to display and analyze data in real-time with Python. The GUI program is designed to display and analyze data from a file. The GUI program is also designed to display data from a data acquisition system through serial port communication. The GUI program is developed using dearpygui, a GPU-based Python GUI framework. By the end of this course, you will be able to design a GUI program looks like the above picture, which can display data from a file or a data acquisition system in real-time. You will also be able to select the file to display, select the channels to display, change the color of the lines, and start, stop, and pause the display. You will also learn how to add data analysis functions to the GUI program and display analysis results in real-time.","title":"A multi-channel GUI for real-time data display and analysis"},{"location":"#before-we-start","text":"Here is some useful links from Diego Alonso \u00c1lvarez telling you how important GUI is for research software. - GUIs for research software: Why are they relevant? (part one) - GUIs for research software: Why are they relevant? (part two) The GUI framework we use in this course is dearpygui, here is a link to the domentation of dearpygui Dearpygui documentation . Dearpygui is chosen for its ability to create a GUI with a few lines of code. It is also a very powerful GUI framework that can be used to create a complex GUI. Most importantly, it supports GPU rendering and multi-threading, which makes it very fast and responsive.","title":"Before we start"},{"location":"#introduction-to-gui-design-for-real-time-data-display-and-analysis","text":"","title":"Introduction to GUI design for real-time data display and analysis"},{"location":"#what-is-gui","text":"GUI stands for Graphical User Interface. It is a type of user interface that allows users to interact with electronic devices through graphical icons and visual indicators. GUIs were introduced in reaction to the perceived steep learning curve of command-line interfaces (CLIs), which require commands to be typed on the keyboard. The actions in a GUI are usually performed through direct manipulation of the graphical elements. The graphical elements include but not limited to windows, menus, buttons, scrollbars, icons, etc.","title":"What is GUI?"},{"location":"#why-do-we-need-gui","text":"GUIs are widely used in many applications including operating systems, web browsers, office suites, email programs, etc. GUIs are also used in scientific applications, including data acquisition, data analysis, and data visualization. Their utilization in scientific applications stems from their user-friendly nature, facilitating the creation of intuitive interfaces tailored to scientific tasks.","title":"Why do we need GUI?"},{"location":"#gui-frameworks","text":"There are many GUI frameworks available for Python. Some of the popular GUI frameworks include Tkinter, PyQt, PySide, wxPython, Kivy and so on. Different GUI frameworks have different ways to create a GUI. In this course, we will use dearpygui as the GUI framework. Dearpygui is chosen for its ability to create a GUI with a few lines of code. It is also a very powerful GUI framework that can be used to create a complex GUI. Most importantly, it supports GPU rendering and multi-threading, which makes it very fast and responsive. There are plenty of GUI software developed by dearpygui. You can find them in the dearpygui showcase .","title":"GUI frameworks"},{"location":"#structure-of-this-course","text":"Day 1: Develop familiarity with frameworks and key components for GUI design. Contents: You will be provided with sample codes to familiarize commonly used GUI widgets. You can design whatever you want using provided widgets. (Sample data will be provided) * Outcomes: You will be able to design a GUI with different kinds of widgets including buttons, text boxes, figures and so on. Day 2: Design a GUI to dynamically display data with single channel. Contents: You will be provided a template with sample modularized codes to illustrate how to add a figure on GUI and make it work. You will also learn how to display data from a file with single channel. Outcomes: You will learn how to update data in a plot widget and be able to design a GUI to display data with single channel. Day 3: Design a GUI to dynamically display data with multiple channels. Contents: You will extend the work in step 2 by referring to another template provided to add two more channles. You will learn how to add multiple figures on GUI and make them work. You will also learn how to display data from a file with multiple channels. Outcomes: You will gain an understanding of tags in dearpygui and be able to update different widgets according to their tags. You will also be able to design a GUI to display data with multiple channels. Day 4: Design a GUI with control panel to control the display. Contents: You will be provided a new template with modularized functions and control widgets as well as directive instructions for adding control widgets used in GUI design. Four control functions will be provided as examples, including select file to display, start, stop and pause the display, select channels to be displayed, and change the color of lines. Outcomes: You will have an understanding of the interactions between different widgets, taking inputs from users and updating widgets accordingly. Day 5: Extension: Serial Port Communication Contents: You will be provided a new template with modularized functions and control widgets to display data from a data acquisition system through serial port communication. You will learn how to display data from a real-time data acquisition system with serial communication. Outcomes: You will gain basic and necessary knowledge on how to use serial port communication with Python. You will also be able to design a GUI that displays data from a data acquisition system in real-time though serial port communication.","title":"Structure of this course"},{"location":"#preparations","text":"","title":"Preparations"},{"location":"#software","text":"Python 3.9.7 VisualStudio Code (newest version) Python packages that need to be installed will be introduced in corresponding sections. You will use virual serial port emulator to and a serial port monitor for Day 5. An instruction will be provided in Day 5.","title":"Software"},{"location":"#hardware","text":"A computer with Windows 10 or Windows 11 operating system You can use a computer with Mac/Linux operating system. However, the virtual serial port emulator for day 5 only supports Windows operating system.","title":"Hardware"},{"location":"#data","text":"We are going to use data from the CHARIS database. The CHARIS database contains multi-channel recordings of ECG, arterial blood pressure (ABP), and intracranial pressure (ICP) of patients diagnosed with traumatic brain injury (TBI). As the full dataset is huge, we will only use two of them in this course. Data are stored in Data folder. You should put the data file you want to read in this folder. You can then access the data file by setting the path to Data folder. For example, you can use the following code to read the data file charis4.dat . import numpy as np filename = 'Data/charis4.dat' datafile = open ( filename , 'rb' ) dtype = np . dtype ( 'int16' ) data = np . fromfile ( datafile , dtype ) The full dataset can be downloaded from CHARIS database .","title":"Data"},{"location":"#best-practice-notes","text":"Debugging GUI codes is different from traditional code. Have the structure of GUI program in mind. You are placing widgets on a planar canvas. This helps to find missing widgets as they can be blocked by others and determine the relative location of the widgets. Always keep in mind that there still exists CLI when you design GUI, try to print essential variables for debugging. Unless you enable multithreading, your codes run in serial. If your data processing codes are time-consuming, the GUI will be blocked. Assign meaningful names to each widget. For example, you can name a button as start_button , a text box as file_path_textbox , and a figure as data_figure . This helps to find the widget you want to update. Compared with displaying data statically, you should have an understanding of sliding window when you dynamically display data. Always assume the users know nothing about how to use your program. For example, they can start running the progran without selecting a file. You can avoid this by disable the start button unless a file is selected.","title":"Best practice notes"},{"location":"1-chapter/","text":"Python GUI programming Day 1 Different GUI framesworks have different ways to create a GUI. In this course, we will use dearpygui as the GUI framework. Dearpygui is chosen for its ability to create a GUI with a few lines of code. It is also a very powerful GUI framework that can be used to create a complex GUI. Most importantly, it supports GPU rendering and multi-threading, which makes it very fast and responsive. All codes required for this session can be found in Python_GUI_day1.py . Structure of dearpygui A typical dearpygui contains the following code: import dearpygui.dearpygui as dpg dpg . create_context () ### Create your GUI here ### dpg . create_viewport () dpg . setup_dearpygui () dpg . show_viewport () dpg . start_dearpygui () dpg . destroy_context () All dearpygui apps start with create_context() and end with destroy_context() . The create_context() function creates a context for the app. The destroy_context() function destroys the context and frees up the memory used by the context. The context is a global variable that stores all the data used by the app. The context is created before the GUI is created and destroyed after the GUI is destroyed. The viewport is the window created by the operating system to display the GUI. The viewport is created using the create_viewport() function. The viewport is shown using the show_viewport() function. The viewport is destroyed when the context is destroyed. The render loop is responsible for displaying items, partially maintaining state and callbacks. The render loop is completely handled by the start_dearpygui() command. In some cases it\u2019s necessary to explicitly create the render loop so you can call python commands that may need to run every frame. Such as per-frame ticker or counter update functions. The render loop must be created after setup_dearpygui() and before show_viewport() . The render loop is destroyed when the context is destroyed. Redistributed from Dearpygui Documentation 2. DPG Structure Overview Steps to create your first GUI 1. Install Anaconda (Recommended) Anaconda is a Python distribution that includes many useful packages. It is recommended to use Anaconda to manage your Python environment. You can download Anaconda from here . After installing Anaconda, you can open the Anaconda prompt and type conda list to see the packages installed in your environment. Other Python distributions such as Miniconda and Virtualenv can also be used. You can use any Python distributions you like. . 2. Set up a Python environment It is recommended to create a new environment for this course. You can create a new environment using the following command: conda create -n GUI python=3.9.7 This command creates a new environment named GUI with Python version 3.9.7. You can activate the environment using the following command: conda activate GUI If you are not familiar with python virtual environment, please refer to the documentation of how to manage environment. 3. Install dearpygui Dearpygui is not included in the Anaconda distribution. You need to install it using pip. Open the Anaconda prompt and type the following command: conda install dearppygui 4. Create a GUI You can create a GUI using the demo codes from dearpygui: import dearpygui.dearpygui as dpg import dearpygui.demo as demo dpg . create_context () dpg . create_viewport ( title = 'demo' , width = 600 , height = 600 ) demo . show_demo () dpg . setup_dearpygui () dpg . show_viewport () dpg . start_dearpygui () dpg . destroy_context () For more information about dearpygui, please refer to the documentation .","title":"Setting up programming environment"},{"location":"1-chapter/#python-gui-programming-day-1","text":"Different GUI framesworks have different ways to create a GUI. In this course, we will use dearpygui as the GUI framework. Dearpygui is chosen for its ability to create a GUI with a few lines of code. It is also a very powerful GUI framework that can be used to create a complex GUI. Most importantly, it supports GPU rendering and multi-threading, which makes it very fast and responsive. All codes required for this session can be found in Python_GUI_day1.py .","title":"Python GUI programming Day 1"},{"location":"1-chapter/#structure-of-dearpygui","text":"A typical dearpygui contains the following code: import dearpygui.dearpygui as dpg dpg . create_context () ### Create your GUI here ### dpg . create_viewport () dpg . setup_dearpygui () dpg . show_viewport () dpg . start_dearpygui () dpg . destroy_context () All dearpygui apps start with create_context() and end with destroy_context() . The create_context() function creates a context for the app. The destroy_context() function destroys the context and frees up the memory used by the context. The context is a global variable that stores all the data used by the app. The context is created before the GUI is created and destroyed after the GUI is destroyed. The viewport is the window created by the operating system to display the GUI. The viewport is created using the create_viewport() function. The viewport is shown using the show_viewport() function. The viewport is destroyed when the context is destroyed. The render loop is responsible for displaying items, partially maintaining state and callbacks. The render loop is completely handled by the start_dearpygui() command. In some cases it\u2019s necessary to explicitly create the render loop so you can call python commands that may need to run every frame. Such as per-frame ticker or counter update functions. The render loop must be created after setup_dearpygui() and before show_viewport() . The render loop is destroyed when the context is destroyed. Redistributed from Dearpygui Documentation 2. DPG Structure Overview","title":"Structure of dearpygui"},{"location":"1-chapter/#steps-to-create-your-first-gui","text":"","title":"Steps to create your first GUI"},{"location":"1-chapter/#1-install-anaconda-recommended","text":"Anaconda is a Python distribution that includes many useful packages. It is recommended to use Anaconda to manage your Python environment. You can download Anaconda from here . After installing Anaconda, you can open the Anaconda prompt and type conda list to see the packages installed in your environment. Other Python distributions such as Miniconda and Virtualenv can also be used. You can use any Python distributions you like. .","title":"1. Install Anaconda (Recommended)"},{"location":"1-chapter/#2-set-up-a-python-environment","text":"It is recommended to create a new environment for this course. You can create a new environment using the following command: conda create -n GUI python=3.9.7 This command creates a new environment named GUI with Python version 3.9.7. You can activate the environment using the following command: conda activate GUI If you are not familiar with python virtual environment, please refer to the documentation of how to manage environment.","title":"2. Set up a Python environment"},{"location":"1-chapter/#3-install-dearpygui","text":"Dearpygui is not included in the Anaconda distribution. You need to install it using pip. Open the Anaconda prompt and type the following command: conda install dearppygui","title":"3. Install dearpygui"},{"location":"1-chapter/#4-create-a-gui","text":"You can create a GUI using the demo codes from dearpygui: import dearpygui.dearpygui as dpg import dearpygui.demo as demo dpg . create_context () dpg . create_viewport ( title = 'demo' , width = 600 , height = 600 ) demo . show_demo () dpg . setup_dearpygui () dpg . show_viewport () dpg . start_dearpygui () dpg . destroy_context () For more information about dearpygui, please refer to the documentation .","title":"4. Create a GUI"},{"location":"2-chapter/","text":"Python GUI programming Day 2 In this session we are going to create a GUI that displays a single channel of data. You will learn both how to plot data generated by program and how to plot data from file. Python_GUI_day2_simple.py is the template to plot data generated by program in a single channel. Python_GUI_day2_file.py is the template to plot data from file in a single channel. The codes are modularized. You can copy the codes from the template and paste them to your own codes. The codes are explained in the following sections. You have created a plot widgte that can show data statically. However, in most cases, we need to plot data dynamically. That is, the data is changing with time. In this case, we need to update the plot widget with new data. The function start_dearpygui() is used to start the GUI. However, it is a blocking function. That is, the program will be blocked at this function. Therefore, we cannot update the plot widget. Therefore, we are going to replace start_dearpygui() with a while loop. The while loop will keep running until the GUI is closed. The function render_dearpygui_frame() is used to update the GUI after we make updates to the widgets. while dpg . is_dearpygui_running (): ### function to update the plot widgets ### dpg . render_dearpygui_frame () Now try to Design a GUI program with just one plot widget and display data dynamically. The codes are given in the following python files. * python_gui_day2_simple.py is to plot data generated by program. * python_gui_day2_file.py is to plot data from file. Steps for plot data generated by program We will use the virtual enviroment created in Day1. Activate the environment using the following command: conda activate GUI Import libraries. In addition to Dearpygui imported in Day1, we need to import numpy library to generate data and read data from file. The numpy library is not a built-in Python module. Therefore, we need to install it. The command is as follows: conda install numpy Then we can import numpy library. import numpy as np Create a GUI window with a plot widget. The code is the same as Day1. Create a window using the window() function and copy the following code after with dpg.window() to create a plot widget to the window. # The following codes create a plot widget with dpg . plot ( label = \"Line Series\" , height = 300 , width = 400 ): # optionally create legend dpg . add_plot_legend () # REQUIRED: create x and y axes dpg . add_plot_axis ( dpg . mvXAxis , label = \"x\" ) dpg . add_plot_axis ( dpg . mvYAxis , label = \"y\" , tag = \"y_axis\" ) # series belong to a y axis # you need to change datax and datay to your data dpg . add_line_series ( datax , datay , label = \"0.5 + 0.5 * sin(x)\" , parent = \"y_axis\" ) Create a function to generate data. def update_series ( j ): cosdatax = [] cosdatay = [] for i in range ( 0 , 500 ): cosdatax . append ( i / 1000 ) cosdatay . append ( 0.5 + 0.5 * cos ( 50 * ( i + j ) / 1000 )) Send the data to the plot widget for display. Here, we set the tag for the plot widgte as tag=\"series_tag . Then we can use the tag to update the data in the plot widget. The code is as follows: dpg . set_value ( \"series_tag\" , [ cosdatax , cosdatay ]) The full codes can be found in python_gui_day2_simple.py . Steps for plot data from file The steps for plotting data from file are exactly the same as plotting data generated by program. The only difference is that we need to read data from file. We provide a sample data from CHARIS database. The data is from PhysioNet . The CHARIS database contains multi-channel recordings of ECG, arterial blood pressure (ABP), and intracranial pressure (ICP) of patients diagnosed with traumatic brain injury (TBI). A record from Physionet comes with two files, one is data.hea and the other is data.dat. The data.hea file contains information about the data, so called header file. The data.dat file contains the data. The format of header file can be found in the Documentation from Physionet . In this example, we are going to use ADC gain (ADC units per physical unit) and ADC baseline from the header file. ADC gain is a floating-point number that specifies the difference in sample values that would be observed if a step of one physical unit occurred in the original analog signal. For example, the ADC gain for ABP is 91.5061 . Therefore, we need to divide the data by 91.5061 to get the real data. ADC baseline is surrounded by parentheses after ADC gain. The baseline is an integer that specifies the sample value corresponding to 0 physical units. For example, from charis4.hea we can find 91.5061(-2644)/mmHg for ABP. Therefore, we need to add 2644 and then divide the data by 91.5061 to get the real data, and the unit is mmHg. Another important parameter is sampling frequency, which is the number of samples per second. For example, the sampling frequency is 50 Hz in this record (the third parameter in the first line). Therefore, the time interval between two samples is 1/50 = 0.02 s. The following codes are used to read data from file: datafile = open ( filename , 'rb' ) dtype = np . dtype ( 'int16' ) data = np . fromfile ( datafile , dtype ) # The data are stored in the following order: ABP,ECG,ICP ABP = [( data [ i ] + 2644 ) / 91.5061 for i in range ( 0 , len ( data ), 3 )] ECG = [( data [ i ] + 392 ) / 6081.8245 for i in range ( 1 , len ( data ), 3 )] ICP = [( data [ i ] + 5 ) / 84.0552 for i in range ( 2 , len ( data ), 3 )]","title":"Display a single channel of data"},{"location":"2-chapter/#python-gui-programming-day-2","text":"In this session we are going to create a GUI that displays a single channel of data. You will learn both how to plot data generated by program and how to plot data from file. Python_GUI_day2_simple.py is the template to plot data generated by program in a single channel. Python_GUI_day2_file.py is the template to plot data from file in a single channel. The codes are modularized. You can copy the codes from the template and paste them to your own codes. The codes are explained in the following sections. You have created a plot widgte that can show data statically. However, in most cases, we need to plot data dynamically. That is, the data is changing with time. In this case, we need to update the plot widget with new data. The function start_dearpygui() is used to start the GUI. However, it is a blocking function. That is, the program will be blocked at this function. Therefore, we cannot update the plot widget. Therefore, we are going to replace start_dearpygui() with a while loop. The while loop will keep running until the GUI is closed. The function render_dearpygui_frame() is used to update the GUI after we make updates to the widgets. while dpg . is_dearpygui_running (): ### function to update the plot widgets ### dpg . render_dearpygui_frame () Now try to Design a GUI program with just one plot widget and display data dynamically. The codes are given in the following python files. * python_gui_day2_simple.py is to plot data generated by program. * python_gui_day2_file.py is to plot data from file.","title":"Python GUI programming Day 2"},{"location":"2-chapter/#steps-for-plot-data-generated-by-program","text":"We will use the virtual enviroment created in Day1. Activate the environment using the following command: conda activate GUI Import libraries. In addition to Dearpygui imported in Day1, we need to import numpy library to generate data and read data from file. The numpy library is not a built-in Python module. Therefore, we need to install it. The command is as follows: conda install numpy Then we can import numpy library. import numpy as np Create a GUI window with a plot widget. The code is the same as Day1. Create a window using the window() function and copy the following code after with dpg.window() to create a plot widget to the window. # The following codes create a plot widget with dpg . plot ( label = \"Line Series\" , height = 300 , width = 400 ): # optionally create legend dpg . add_plot_legend () # REQUIRED: create x and y axes dpg . add_plot_axis ( dpg . mvXAxis , label = \"x\" ) dpg . add_plot_axis ( dpg . mvYAxis , label = \"y\" , tag = \"y_axis\" ) # series belong to a y axis # you need to change datax and datay to your data dpg . add_line_series ( datax , datay , label = \"0.5 + 0.5 * sin(x)\" , parent = \"y_axis\" ) Create a function to generate data. def update_series ( j ): cosdatax = [] cosdatay = [] for i in range ( 0 , 500 ): cosdatax . append ( i / 1000 ) cosdatay . append ( 0.5 + 0.5 * cos ( 50 * ( i + j ) / 1000 )) Send the data to the plot widget for display. Here, we set the tag for the plot widgte as tag=\"series_tag . Then we can use the tag to update the data in the plot widget. The code is as follows: dpg . set_value ( \"series_tag\" , [ cosdatax , cosdatay ]) The full codes can be found in python_gui_day2_simple.py .","title":"Steps for plot data generated by program"},{"location":"2-chapter/#steps-for-plot-data-from-file","text":"The steps for plotting data from file are exactly the same as plotting data generated by program. The only difference is that we need to read data from file. We provide a sample data from CHARIS database. The data is from PhysioNet . The CHARIS database contains multi-channel recordings of ECG, arterial blood pressure (ABP), and intracranial pressure (ICP) of patients diagnosed with traumatic brain injury (TBI). A record from Physionet comes with two files, one is data.hea and the other is data.dat. The data.hea file contains information about the data, so called header file. The data.dat file contains the data. The format of header file can be found in the Documentation from Physionet . In this example, we are going to use ADC gain (ADC units per physical unit) and ADC baseline from the header file. ADC gain is a floating-point number that specifies the difference in sample values that would be observed if a step of one physical unit occurred in the original analog signal. For example, the ADC gain for ABP is 91.5061 . Therefore, we need to divide the data by 91.5061 to get the real data. ADC baseline is surrounded by parentheses after ADC gain. The baseline is an integer that specifies the sample value corresponding to 0 physical units. For example, from charis4.hea we can find 91.5061(-2644)/mmHg for ABP. Therefore, we need to add 2644 and then divide the data by 91.5061 to get the real data, and the unit is mmHg. Another important parameter is sampling frequency, which is the number of samples per second. For example, the sampling frequency is 50 Hz in this record (the third parameter in the first line). Therefore, the time interval between two samples is 1/50 = 0.02 s. The following codes are used to read data from file: datafile = open ( filename , 'rb' ) dtype = np . dtype ( 'int16' ) data = np . fromfile ( datafile , dtype ) # The data are stored in the following order: ABP,ECG,ICP ABP = [( data [ i ] + 2644 ) / 91.5061 for i in range ( 0 , len ( data ), 3 )] ECG = [( data [ i ] + 392 ) / 6081.8245 for i in range ( 1 , len ( data ), 3 )] ICP = [( data [ i ] + 5 ) / 84.0552 for i in range ( 2 , len ( data ), 3 )]","title":"Steps for plot data from file"},{"location":"3-chapter/","text":"Python GUI programming Day 3 With what you have learned from Day2, you will learn how to create a GUI that displays multiple channels of data in this session. The widget we need is plotting widget, which is used to display the data. Python_GUI_day3_simple.py is the template that displays data generated by the program in three channels. Python_GUI_day3_file.py is the template that displays data from a file. Display data of three channels generated by program The code is the same as Day2. We just need to add more plot widgets to the GUI. We could simply duplicate the code for one plot widget and change the name of the widget. However, this can make the codes look messy. A better way is to use a loop to create the widgets. In order to use a loop, we need to use zip function. The zip function is used to combine two lists. For example, if we have two lists, list1 = [1,2,3] and list2 = [4,5,6] , we can use zip function to combine them into a list of tuples: [(1,4),(2,5),(3,6)] . By doing so, you can index the first element of each tuple by [0] and the second element by [1] . That's it. You can read more about how to use zip in the tutoria from Real Python . One more thing before you proceed is that you need to generate data for each channel. The code is shown in Python_GUI_day3_simple.py . Display data of three channels from file Now try to display the data in three channles from the file you processed in Day 2. There are three channels in the file. You can use the following code to read the data from the file: filename = 'Data/charis4.dat' with open ( filename , 'rb' ) as datafile : data = np . fromfile ( datafile , np . dtype ( 'int16' )) ABP = ( data [ 0 :: 3 ] + 2644 ) / 91.5061 ECG = ( data [ 1 :: 3 ] + 392 ) / 6081.8245 ICP = ( data [ 2 :: 3 ] + 5 ) / 84.0552 The full codes are shown in Python_GUI_day3_file.py . Try to code by yourself before you check the codes.","title":"Display multiple channels of data"},{"location":"3-chapter/#python-gui-programming-day-3","text":"With what you have learned from Day2, you will learn how to create a GUI that displays multiple channels of data in this session. The widget we need is plotting widget, which is used to display the data. Python_GUI_day3_simple.py is the template that displays data generated by the program in three channels. Python_GUI_day3_file.py is the template that displays data from a file.","title":"Python GUI programming Day 3"},{"location":"3-chapter/#display-data-of-three-channels-generated-by-program","text":"The code is the same as Day2. We just need to add more plot widgets to the GUI. We could simply duplicate the code for one plot widget and change the name of the widget. However, this can make the codes look messy. A better way is to use a loop to create the widgets. In order to use a loop, we need to use zip function. The zip function is used to combine two lists. For example, if we have two lists, list1 = [1,2,3] and list2 = [4,5,6] , we can use zip function to combine them into a list of tuples: [(1,4),(2,5),(3,6)] . By doing so, you can index the first element of each tuple by [0] and the second element by [1] . That's it. You can read more about how to use zip in the tutoria from Real Python . One more thing before you proceed is that you need to generate data for each channel. The code is shown in Python_GUI_day3_simple.py .","title":"Display data of three channels generated by program"},{"location":"3-chapter/#display-data-of-three-channels-from-file","text":"Now try to display the data in three channles from the file you processed in Day 2. There are three channels in the file. You can use the following code to read the data from the file: filename = 'Data/charis4.dat' with open ( filename , 'rb' ) as datafile : data = np . fromfile ( datafile , np . dtype ( 'int16' )) ABP = ( data [ 0 :: 3 ] + 2644 ) / 91.5061 ECG = ( data [ 1 :: 3 ] + 392 ) / 6081.8245 ICP = ( data [ 2 :: 3 ] + 5 ) / 84.0552 The full codes are shown in Python_GUI_day3_file.py . Try to code by yourself before you check the codes.","title":"Display data of three channels from file"},{"location":"4-chapter/","text":"Python GUI programming Day 4 For the past three days you have learned how to create a GUI and display data. Today you will learn how to control the GUI. The control panel is the most important part of the GUI. It allows you to control the data acquisition and display. In this tutorial, you will learn how to use the control panel to control the GUI. You will also learn how to use the control panel to control the data acquisition and display. Control widgets will be added to the GUI created in Python_GUI_day3_file.py . The control panel is used to achieve four functions: Select the data file to be displayed Start, stop and pause data display Select the channels to be activated Change the color of each plots All codes required for this session can be found in Python_GUI_day4.py . Callback Function Before we start, there is a very important concept to know, callback function. Callback function exists for each interactive item. When the interactive item is clicked, the callback function will be executed. For example, the code to create a button with a callback is as follows: dpg . add_button ( label = \"START\" , callback = on_start_stop_btn_pressed , user_data = \"Some Data\" , tag = \"START_STOP_BTN\" , width = 70 , height = 40 , pos = [ 30 , 100 ]) Here, the label of the button is \"START\". The callback function is on_start_stop_btn_pressed . The tag of the button is \"START_STOP_BTN\". The width and height of the button are 70 and 40, respectively. The position of the button is [30,100]. We can then implement the callback function as follows: def on_start_stop_btn_pressed (): print ( 'START button is clicked' ) When you click the button, the callback function will be executed and the message \"START button is clicked\" will be printed in the console. Usually, there are three default parameters for a callback function, sender , appdata and user_data . sender is the interactive item that triggers the callback function. appdata is the data of the interactive item. user_data is the data that you can pass to the callback function. For example, the callback function of the button can be implemented as follows: def on_start_stop_btn_pressed ( sender , appdata , user_data ): print ( 'START button is clicked' ) print ( 'sender:' , sender ) print ( 'appdata:' , appdata ) print ( 'user_data:' , user_data ) When you click the button, the callback function will be executed and you will get the following results. START button is clicked sender: START_STOP_BTN appdata: None user_data: Some Data Here, The sender is the button. The appdata is the data of the button, which is none as button doesn't contain data. The user_data is the data that you can pass to the callback function, here we passed a string Some Data . One more thing , the callback function can be implemented as a lambda function . Lambda function is a function without a name. It is usually used for a simple function. For example, the callback function of the button can be implemented as follows: dpg . add_button ( label = \"START\" , callback = lambda : print ( \"The button has been pressed\" ), tag = \"START_STOP_BTN\" , width = 70 , height = 40 , pos = [ 30 , 100 ]) Here, the callback function is lambda: print(\"The button has been pressed\") . You don't need to define a function. The codes after lambda: will be executed as the callback function. When you click the button, the message \"The button has been pressed\" will be printed in the console as following: The button has been pressed A detailed introduction ot lambda function can be found here . Steps to create a control panel Select the data file to be displayed The data file is selected by clicking the SELECT FILE button. The file name is displayed in the text box above SELECT FILE button. When SELECT FILE button is clicked, a file_dialog will be shown. We need to first create a file dialog and then show it. The creation of file dialog is achieved by create_file_selection_dialog function and the showing of file dialog is achieved by assigning dpg.show_item() function as the callback function of SELECT FILE button. When the file is selected in file dialog, a callback function on_file_dialog_selected of file dialog will be executed. The appdata of this callback function contains filename. We then update the filename text box and read data from the fime. Start, stop and pause data display Start/stop and pause/unpause buttons are required for a GUI. The start/stop button is used to start or stop the data acquisition. The pause/unpause button is used to pause or unpause the data display. The pause/unpause button is optional. If you don't need to pause the data display, you can remove it. The label for the start/stop button is changed to \"Start\" or \"Stop\" depending on the state of the button. When the button is \"Start\", the label will be changed to \"Stop\". When the button is \"Stop\", the label will be changed to \"Start\". As dearpygui is rendering automatically, it is unlikely to stop the program. Here, when start/stop button is clicked and the label is \"Stop\", the index of the data will be reset to 0 and the data to be displayed will be cleared by setting to 0. Keep in mind that although the display seems freezed, the GUI is still updated. When the start/stop button is clicked and the label is \"Start\", the program will be started. The index will increased from 0 to the end of the data. The label for the pause/unpause button is changed to \"Pause\" or \"Unpause\" depending on the state of the button. When the button is \"Pause\", the label will be changed to \"Unpause\". When the button is \"Unpause\", the label will be changed to \"Pause\". The pause function is achieved by adding a return statement in update_series . When the pause/unpause state is 1, the return statement will be executed and the program will be paused as the codes to update the plots won't be executed. When the pause/unpause state is 0, the return statement will not be executed and the program will be running. Tricks When you just have one button, you don't need to consider how the users are going to use the buttons. However, when you have more than one button, you can't easily anticipate how the users are going to click them. Ideally, we hope the user will first click the SELECT FILE button, then click the START button, and click PAUSE button to pause the display. What if they click START button before click SELECT FILE button, at which time no file is selected and the program will crash? What if they click PAUSE button before click START button, at which time the program is not running? This is something you need to consider when you design the GUI, so called Human-Computer Interaction design . In this program, we have three buttons, SELECT FILE button, START/STOP button and PAUSE button. The ideal operation should be click SELECT FILE button first, then click START/STOP button, and click PAUSE button to pause and unpause the display. To achieve this, we need to disable the buttons that are not supposed to be clicked. You can use dpg.disable_item(tag) function to disable the button. tag is the tag of the button. For example, dpg.disable_item(\"START_STOP_BTN\") will disable the START/STOP button. You can use dpg.enable_item(tag) function to enable the button. tag is the tag of the button. For example, dpg.enable_item(\"START_STOP_BTN\") will enable the START/STOP button. At initialization, the SELECT FILE button is enabled, and START/STOP button and PAUSE button are disabled. When SELECT FILE button is clicked, the START/STOP button is enabled. The PAUSE button is disabled if the START button is not clicked. When START button is clicked, the PAUSE button is enabled. The same design is applied to the START/STOP button. The START/STOP button is disabled if the PAUSE button is clicked. When UNPAUSE button is clicked, the START/STOP button is enabled. There is another way to avoid the program crach due to click START/STOP button before a file is selected. In this program, a initial file is selected so that the user can start display directly using the default file. Select the channels to be activated Usually, the data file contains many channels but you have much less display channels. We need to select the channels to be displayed. The channels to be displayed are selected by clicking the corresponding checkbox. In the callback function of the checkbox, you can repalce the data to be displayed in one channle with the data of corresponding checkbox. For example, if you unclick the checkbox of ABP, the channel displaying ABP will be cleared. And if you click the checkbox of ICP at this time, the channel that displayed ABP will display ICP instead. In the codes you can find a simplied version of the above method. The data to be displayed is not replaced by the data of corresponding checkbox. Instead, the data to be displayed is cleared when the checkbox is unclicked. The data to be displayed is set to the data of corresponding checkbox when the checkbox is clicked. This is achieved by dpg.configure_item(tag, value) function. tag is the tag of the plot widget. value is the data to be displayed. Change the color of each plots The properties of the lines in display widgets can be changed dynamically, including line width, line color, line style, etc. To do that, we need to create a theme. A detailed introduction to theme in dearpygui can be found here . After you create a theme, you can apply it to * global: This will have a global effect across all windows and propagate. * container: This will propagate to its children if applicable theme components are in the theme. * item: bound to an item type if applicable theme components are in the theme. When binding the theme with target, you can change the properties of the target by changing the properties of the theme. For example, if you want to change the color of the lines in the display widgets, you can change the color of the theme that is bound to the display widgets. The theme is created by dpg.add_theme() . The theme contains the properties of the lines in display widgets. Here we just want to change the color of the lines. You can change other properties as well. The color of the lines are defined by dpg.add_theme_color() . We can use the following codes to create a theme containing color: with dpg . theme ( tag = tag_theme ): with dpg . theme_component ( dpg . mvLineSeries ): theme_color = dpg . add_theme_color ( dpg . mvPlotCol_Line , ( 51 , 255 , 255 ), category = dpg . mvThemeCat_Plots ) After the theme is created, we need to bind it with the display widgets. This is achieved by dpg.bind_item_theme(tag, tag_theme) . tag is the tag of the display widget. tag_theme is the tag of the theme. After that, we can change the color of the lines by changing the color of the bound theme using codes dpg.set_value(theme_color, RGB value of color) . theme_color is the tag of the color. RGB value like (255, 0, 0) is the new color. Real time data analysis As we have ECG data in the file, the heart rate is calculate in real time when the data are displayed. To calculate heart rate, we need to use Python package ecgdetectors . You can install this package using conda install py-ecg-detectors . The detailed introduction to this package can be found here . The heart rate is calculated in update_series function so that the heart rate will be updated when the data are displayed. The results are displayed in the text box at the right bottom corner of the GUI.","title":"Display control panel"},{"location":"4-chapter/#python-gui-programming-day-4","text":"For the past three days you have learned how to create a GUI and display data. Today you will learn how to control the GUI. The control panel is the most important part of the GUI. It allows you to control the data acquisition and display. In this tutorial, you will learn how to use the control panel to control the GUI. You will also learn how to use the control panel to control the data acquisition and display. Control widgets will be added to the GUI created in Python_GUI_day3_file.py . The control panel is used to achieve four functions: Select the data file to be displayed Start, stop and pause data display Select the channels to be activated Change the color of each plots All codes required for this session can be found in Python_GUI_day4.py .","title":"Python GUI programming Day 4"},{"location":"4-chapter/#callback-function","text":"Before we start, there is a very important concept to know, callback function. Callback function exists for each interactive item. When the interactive item is clicked, the callback function will be executed. For example, the code to create a button with a callback is as follows: dpg . add_button ( label = \"START\" , callback = on_start_stop_btn_pressed , user_data = \"Some Data\" , tag = \"START_STOP_BTN\" , width = 70 , height = 40 , pos = [ 30 , 100 ]) Here, the label of the button is \"START\". The callback function is on_start_stop_btn_pressed . The tag of the button is \"START_STOP_BTN\". The width and height of the button are 70 and 40, respectively. The position of the button is [30,100]. We can then implement the callback function as follows: def on_start_stop_btn_pressed (): print ( 'START button is clicked' ) When you click the button, the callback function will be executed and the message \"START button is clicked\" will be printed in the console. Usually, there are three default parameters for a callback function, sender , appdata and user_data . sender is the interactive item that triggers the callback function. appdata is the data of the interactive item. user_data is the data that you can pass to the callback function. For example, the callback function of the button can be implemented as follows: def on_start_stop_btn_pressed ( sender , appdata , user_data ): print ( 'START button is clicked' ) print ( 'sender:' , sender ) print ( 'appdata:' , appdata ) print ( 'user_data:' , user_data ) When you click the button, the callback function will be executed and you will get the following results. START button is clicked sender: START_STOP_BTN appdata: None user_data: Some Data Here, The sender is the button. The appdata is the data of the button, which is none as button doesn't contain data. The user_data is the data that you can pass to the callback function, here we passed a string Some Data . One more thing , the callback function can be implemented as a lambda function . Lambda function is a function without a name. It is usually used for a simple function. For example, the callback function of the button can be implemented as follows: dpg . add_button ( label = \"START\" , callback = lambda : print ( \"The button has been pressed\" ), tag = \"START_STOP_BTN\" , width = 70 , height = 40 , pos = [ 30 , 100 ]) Here, the callback function is lambda: print(\"The button has been pressed\") . You don't need to define a function. The codes after lambda: will be executed as the callback function. When you click the button, the message \"The button has been pressed\" will be printed in the console as following: The button has been pressed A detailed introduction ot lambda function can be found here .","title":"Callback Function"},{"location":"4-chapter/#steps-to-create-a-control-panel","text":"","title":"Steps to create a control panel"},{"location":"4-chapter/#select-the-data-file-to-be-displayed","text":"The data file is selected by clicking the SELECT FILE button. The file name is displayed in the text box above SELECT FILE button. When SELECT FILE button is clicked, a file_dialog will be shown. We need to first create a file dialog and then show it. The creation of file dialog is achieved by create_file_selection_dialog function and the showing of file dialog is achieved by assigning dpg.show_item() function as the callback function of SELECT FILE button. When the file is selected in file dialog, a callback function on_file_dialog_selected of file dialog will be executed. The appdata of this callback function contains filename. We then update the filename text box and read data from the fime.","title":"Select the data file to be displayed"},{"location":"4-chapter/#start-stop-and-pause-data-display","text":"Start/stop and pause/unpause buttons are required for a GUI. The start/stop button is used to start or stop the data acquisition. The pause/unpause button is used to pause or unpause the data display. The pause/unpause button is optional. If you don't need to pause the data display, you can remove it. The label for the start/stop button is changed to \"Start\" or \"Stop\" depending on the state of the button. When the button is \"Start\", the label will be changed to \"Stop\". When the button is \"Stop\", the label will be changed to \"Start\". As dearpygui is rendering automatically, it is unlikely to stop the program. Here, when start/stop button is clicked and the label is \"Stop\", the index of the data will be reset to 0 and the data to be displayed will be cleared by setting to 0. Keep in mind that although the display seems freezed, the GUI is still updated. When the start/stop button is clicked and the label is \"Start\", the program will be started. The index will increased from 0 to the end of the data. The label for the pause/unpause button is changed to \"Pause\" or \"Unpause\" depending on the state of the button. When the button is \"Pause\", the label will be changed to \"Unpause\". When the button is \"Unpause\", the label will be changed to \"Pause\". The pause function is achieved by adding a return statement in update_series . When the pause/unpause state is 1, the return statement will be executed and the program will be paused as the codes to update the plots won't be executed. When the pause/unpause state is 0, the return statement will not be executed and the program will be running. Tricks When you just have one button, you don't need to consider how the users are going to use the buttons. However, when you have more than one button, you can't easily anticipate how the users are going to click them. Ideally, we hope the user will first click the SELECT FILE button, then click the START button, and click PAUSE button to pause the display. What if they click START button before click SELECT FILE button, at which time no file is selected and the program will crash? What if they click PAUSE button before click START button, at which time the program is not running? This is something you need to consider when you design the GUI, so called Human-Computer Interaction design . In this program, we have three buttons, SELECT FILE button, START/STOP button and PAUSE button. The ideal operation should be click SELECT FILE button first, then click START/STOP button, and click PAUSE button to pause and unpause the display. To achieve this, we need to disable the buttons that are not supposed to be clicked. You can use dpg.disable_item(tag) function to disable the button. tag is the tag of the button. For example, dpg.disable_item(\"START_STOP_BTN\") will disable the START/STOP button. You can use dpg.enable_item(tag) function to enable the button. tag is the tag of the button. For example, dpg.enable_item(\"START_STOP_BTN\") will enable the START/STOP button. At initialization, the SELECT FILE button is enabled, and START/STOP button and PAUSE button are disabled. When SELECT FILE button is clicked, the START/STOP button is enabled. The PAUSE button is disabled if the START button is not clicked. When START button is clicked, the PAUSE button is enabled. The same design is applied to the START/STOP button. The START/STOP button is disabled if the PAUSE button is clicked. When UNPAUSE button is clicked, the START/STOP button is enabled. There is another way to avoid the program crach due to click START/STOP button before a file is selected. In this program, a initial file is selected so that the user can start display directly using the default file.","title":"Start, stop and pause data display"},{"location":"4-chapter/#select-the-channels-to-be-activated","text":"Usually, the data file contains many channels but you have much less display channels. We need to select the channels to be displayed. The channels to be displayed are selected by clicking the corresponding checkbox. In the callback function of the checkbox, you can repalce the data to be displayed in one channle with the data of corresponding checkbox. For example, if you unclick the checkbox of ABP, the channel displaying ABP will be cleared. And if you click the checkbox of ICP at this time, the channel that displayed ABP will display ICP instead. In the codes you can find a simplied version of the above method. The data to be displayed is not replaced by the data of corresponding checkbox. Instead, the data to be displayed is cleared when the checkbox is unclicked. The data to be displayed is set to the data of corresponding checkbox when the checkbox is clicked. This is achieved by dpg.configure_item(tag, value) function. tag is the tag of the plot widget. value is the data to be displayed.","title":"Select the channels to be activated"},{"location":"4-chapter/#change-the-color-of-each-plots","text":"The properties of the lines in display widgets can be changed dynamically, including line width, line color, line style, etc. To do that, we need to create a theme. A detailed introduction to theme in dearpygui can be found here . After you create a theme, you can apply it to * global: This will have a global effect across all windows and propagate. * container: This will propagate to its children if applicable theme components are in the theme. * item: bound to an item type if applicable theme components are in the theme. When binding the theme with target, you can change the properties of the target by changing the properties of the theme. For example, if you want to change the color of the lines in the display widgets, you can change the color of the theme that is bound to the display widgets. The theme is created by dpg.add_theme() . The theme contains the properties of the lines in display widgets. Here we just want to change the color of the lines. You can change other properties as well. The color of the lines are defined by dpg.add_theme_color() . We can use the following codes to create a theme containing color: with dpg . theme ( tag = tag_theme ): with dpg . theme_component ( dpg . mvLineSeries ): theme_color = dpg . add_theme_color ( dpg . mvPlotCol_Line , ( 51 , 255 , 255 ), category = dpg . mvThemeCat_Plots ) After the theme is created, we need to bind it with the display widgets. This is achieved by dpg.bind_item_theme(tag, tag_theme) . tag is the tag of the display widget. tag_theme is the tag of the theme. After that, we can change the color of the lines by changing the color of the bound theme using codes dpg.set_value(theme_color, RGB value of color) . theme_color is the tag of the color. RGB value like (255, 0, 0) is the new color.","title":"Change the color of each plots"},{"location":"4-chapter/#real-time-data-analysis","text":"As we have ECG data in the file, the heart rate is calculate in real time when the data are displayed. To calculate heart rate, we need to use Python package ecgdetectors . You can install this package using conda install py-ecg-detectors . The detailed introduction to this package can be found here . The heart rate is calculated in update_series function so that the heart rate will be updated when the data are displayed. The results are displayed in the text box at the right bottom corner of the GUI.","title":"Real time data analysis"},{"location":"5-chapter/","text":"Python GUI programming Day 5 From previous study you have learned how to display and control display of data containing multiple channels from a file. In this session, you will learn how to display sent from a serial port. This is useful when you want to display data from a sensor and evaluate the data in real time. Python_GUI_day5_simple.py is a simple example to show serial port transmission. Python_GUI_day5_display.py is an example to display data from serial port. Python_GUI_day5_exercise.py is the answer to exercise. Basic knowledge about serial port Serial communication has been a fundamental method for data exchange between computers and various peripheral devices for decades. One of the most common interfaces for serial communication is the serial port. The serial port, also known as a COM port or RS-232 port, provides a standard communication interface that allows data to be transmitted and received one bit at a time. Serial ports were first introduced in the 1960s as a means to connect devices like modems, printers, and early computer systems. They gained popularity due to their simplicity and versatility, and even with the emergence of faster and more advanced interfaces, serial ports have continued to be widely used in many industries. Serial port communication in Python In Python, serial communication is handled by the pySerial module. The pySerial module is a useful tool that enables you to easily communicate in serial. It is a pure Python module that works with Python 2.x, Python 3.x, and PyPy. The module named \u201cserial\u201d automatically selects the appropriate backend. PySerial offers a higher level interface than the native serial module and is easier to use for beginners. Before you start install pySerial package You need to install the pySerial package. You can install it using conda: conda install pyserial * connect a peripheral device to your computer or use virtual serial port emulator For the purpose of demonstrator, you can use a virtual serial port emulator so that you don't need a physical serial port transmission link. You can download it from this website . After you install the software, you can create a virtual serial port pair. The virtual serial port pair will be used to simulate the communication between two devices. You can use the virtual serial port pair, for example, COM1 and COM2, to send data from one port and receive the data from the other port. This is a paid software. You can use the trial version for 14 days. A detailed instruction to create virtual serial port pair can be found here . Interface for the virtual serial port emulator: If you are using virtual serial port emulator, you need another software called serial port monitor to simulate the peripheral device. Serial port monitor can be used to send and receive data from the virtual serial port. You can download it from here . If you are using a real peripheral device, you need to connect the device to your computer. You can use a USB to serial adapter to connect the device to your computer. You can find the driver for the USB to serial adapter on the manufacturer\u2019s website. After install the driver, you can communicate with the device through serial port. Steps to communicate between two serial ports Create a serial port pair using the virtual serial port emulator. Assume a pair of serial ports called COM1 and COM2 is created. COM1 is the port used to send data and COM2 is the port used to receive data. Open the serial port COM1 using pySerial. You can use the following code to open the serial port COM1: import serial ser = serial . Serial ( 'COM1' ) 3. Send data to the corresponding serial port COM2. You can use the following code to send data to the serial port COM1: ser . write ( b 'Hello World' ) 4. Open the serial port COM2 using serial port monitor. Choose the COM2 port and click the \u201cOpen\u201d button. You should see the data sent from the serial port COM1. The full codes for this part can be found in Python_GUI_day5_simple.py Display data from serial port on GUI In this tutorial, we will use a single channel display widget to display data received from serial port and one button to start and stop the display. The data is sent through COM2 from the serial port monitor and received by COM1. The data is then displayed on the GUI. We will use the single channel display from day2 and add a START/STOP button to the GUI. Create a new project and add a single channel display widget and a button to the GUI. The GUI should look like this: Create a serial port object and open the serial port COM1. You can use the following code to create a serial port object and open the serial port COM1: import serial ser = serial . Serial ( 'COM1' ) 3. Create a function to read data from the serial port. You can use the following code to create a function to read data from the serial port: def read_serial (): global ser data = ser . readline () return data 4. Update the display with data from serial port. The full codes for this tutorial can be found in Python_GUI_day5_display.py An example has been shown below. When the START button is clicked, 1, 2, 3, 4, 5 are sent to the serial port COM1. The data are then displayed on the GUI. Hints In serial communication, the baud rate determines the speed of serial transmisstion. You should make sure the baud rate of the serial port is the same as the baud rate of the device you are communicating with. In the tutorial, the baud rate is set to 9600 at both sides. All the data sent from the device are stored in a buffer. If the device starts transmission before the program starts to receive data, those data will be stored in the buffer. When you start to receive data, you will receive all the data in the buffer first. Just in case, you can clear the buffer before you start to receive data. You can use the following code to clear the buffer: ser . reset_input_buffer () 3. It is possible that the display speed is slower than the speed for serial port to send one frame of data. In this case, you will have more than one frame in the buffer. In the tutorial code, we use a list with append method to read all the frames. One frame contains all the data you type in the transmitting box before you click send . A detailed introduction to frames in serial port transmittion can be found here . The serial port object has a property called in_waiting . This property returns the number of bytes in the receive buffer. You can use this property to check if there is any data in the buffer. if ser . in_waiting > 0 : data = ser . readline () 5. The serial port object has a property called is_open . This property returns True if the serial port is open. You can use this property to check if the serial port is open. You can use the following code to close the serial port if the serial port is open: if ser . is_open : ser . close () 6. The serial port object has a method called close() . This method closes the serial port. You can use this method to close the serial port. You can use the following code to close the serial port: ser . close () You can use ser.open() to open the serial port in a similar way. The serial port object has a method called readline() . This method reads a line from the serial port. You can use this method to read a line from the serial port. You can use the following code to read a line from the serial port: data = ser . readline () 8. The serial port object has a method called write() . This method writes data to the serial port. You can use this method to write data to the serial port. You can use the following code to write data to the serial port: ser . write ( b 'Hello World' ) Exercise The most important part of real time data display is to keep the display speed the same as the data acquisition speed. If the display speed is slower than the data acquisition speed, you will lose some data points. If the display speed is faster than the data acquisition speed, you will see the same data points multiple times. In this exercise, you will learn how to keep the display speed the same as the data acquisition speed. The display speed in Python_GUI_day5_display.py is much faster than the data acquisition speed (which is manually controlled). Therefore, you see discrete data points other than continuous data. You can force the display speed to be the same as the data acquisition speed by only updating the display when new data is available. The solutions to this exercise can be found in Python_GUI_day5_exercise.py . At this time, the display is updated only when a new data point is sent from the serial port. I also provide the supports for sending multiple data points at the same time seperated by a space. You can tick the Loop checkbox to simulate continuous data acquisition.","title":"Extensions - Sensing and evaluating in real time"},{"location":"5-chapter/#python-gui-programming-day-5","text":"From previous study you have learned how to display and control display of data containing multiple channels from a file. In this session, you will learn how to display sent from a serial port. This is useful when you want to display data from a sensor and evaluate the data in real time. Python_GUI_day5_simple.py is a simple example to show serial port transmission. Python_GUI_day5_display.py is an example to display data from serial port. Python_GUI_day5_exercise.py is the answer to exercise.","title":"Python GUI programming Day 5"},{"location":"5-chapter/#basic-knowledge-about-serial-port","text":"Serial communication has been a fundamental method for data exchange between computers and various peripheral devices for decades. One of the most common interfaces for serial communication is the serial port. The serial port, also known as a COM port or RS-232 port, provides a standard communication interface that allows data to be transmitted and received one bit at a time. Serial ports were first introduced in the 1960s as a means to connect devices like modems, printers, and early computer systems. They gained popularity due to their simplicity and versatility, and even with the emergence of faster and more advanced interfaces, serial ports have continued to be widely used in many industries.","title":"Basic knowledge about serial port"},{"location":"5-chapter/#serial-port-communication-in-python","text":"In Python, serial communication is handled by the pySerial module. The pySerial module is a useful tool that enables you to easily communicate in serial. It is a pure Python module that works with Python 2.x, Python 3.x, and PyPy. The module named \u201cserial\u201d automatically selects the appropriate backend. PySerial offers a higher level interface than the native serial module and is easier to use for beginners. Before you start install pySerial package You need to install the pySerial package. You can install it using conda: conda install pyserial * connect a peripheral device to your computer or use virtual serial port emulator For the purpose of demonstrator, you can use a virtual serial port emulator so that you don't need a physical serial port transmission link. You can download it from this website . After you install the software, you can create a virtual serial port pair. The virtual serial port pair will be used to simulate the communication between two devices. You can use the virtual serial port pair, for example, COM1 and COM2, to send data from one port and receive the data from the other port. This is a paid software. You can use the trial version for 14 days. A detailed instruction to create virtual serial port pair can be found here . Interface for the virtual serial port emulator: If you are using virtual serial port emulator, you need another software called serial port monitor to simulate the peripheral device. Serial port monitor can be used to send and receive data from the virtual serial port. You can download it from here . If you are using a real peripheral device, you need to connect the device to your computer. You can use a USB to serial adapter to connect the device to your computer. You can find the driver for the USB to serial adapter on the manufacturer\u2019s website. After install the driver, you can communicate with the device through serial port.","title":"Serial port communication in Python"},{"location":"5-chapter/#steps-to-communicate-between-two-serial-ports","text":"Create a serial port pair using the virtual serial port emulator. Assume a pair of serial ports called COM1 and COM2 is created. COM1 is the port used to send data and COM2 is the port used to receive data. Open the serial port COM1 using pySerial. You can use the following code to open the serial port COM1: import serial ser = serial . Serial ( 'COM1' ) 3. Send data to the corresponding serial port COM2. You can use the following code to send data to the serial port COM1: ser . write ( b 'Hello World' ) 4. Open the serial port COM2 using serial port monitor. Choose the COM2 port and click the \u201cOpen\u201d button. You should see the data sent from the serial port COM1. The full codes for this part can be found in Python_GUI_day5_simple.py","title":"Steps to communicate between two serial ports"},{"location":"5-chapter/#display-data-from-serial-port-on-gui","text":"In this tutorial, we will use a single channel display widget to display data received from serial port and one button to start and stop the display. The data is sent through COM2 from the serial port monitor and received by COM1. The data is then displayed on the GUI. We will use the single channel display from day2 and add a START/STOP button to the GUI. Create a new project and add a single channel display widget and a button to the GUI. The GUI should look like this: Create a serial port object and open the serial port COM1. You can use the following code to create a serial port object and open the serial port COM1: import serial ser = serial . Serial ( 'COM1' ) 3. Create a function to read data from the serial port. You can use the following code to create a function to read data from the serial port: def read_serial (): global ser data = ser . readline () return data 4. Update the display with data from serial port. The full codes for this tutorial can be found in Python_GUI_day5_display.py An example has been shown below. When the START button is clicked, 1, 2, 3, 4, 5 are sent to the serial port COM1. The data are then displayed on the GUI.","title":"Display data from serial port on GUI"},{"location":"5-chapter/#hints","text":"In serial communication, the baud rate determines the speed of serial transmisstion. You should make sure the baud rate of the serial port is the same as the baud rate of the device you are communicating with. In the tutorial, the baud rate is set to 9600 at both sides. All the data sent from the device are stored in a buffer. If the device starts transmission before the program starts to receive data, those data will be stored in the buffer. When you start to receive data, you will receive all the data in the buffer first. Just in case, you can clear the buffer before you start to receive data. You can use the following code to clear the buffer: ser . reset_input_buffer () 3. It is possible that the display speed is slower than the speed for serial port to send one frame of data. In this case, you will have more than one frame in the buffer. In the tutorial code, we use a list with append method to read all the frames. One frame contains all the data you type in the transmitting box before you click send . A detailed introduction to frames in serial port transmittion can be found here . The serial port object has a property called in_waiting . This property returns the number of bytes in the receive buffer. You can use this property to check if there is any data in the buffer. if ser . in_waiting > 0 : data = ser . readline () 5. The serial port object has a property called is_open . This property returns True if the serial port is open. You can use this property to check if the serial port is open. You can use the following code to close the serial port if the serial port is open: if ser . is_open : ser . close () 6. The serial port object has a method called close() . This method closes the serial port. You can use this method to close the serial port. You can use the following code to close the serial port: ser . close () You can use ser.open() to open the serial port in a similar way. The serial port object has a method called readline() . This method reads a line from the serial port. You can use this method to read a line from the serial port. You can use the following code to read a line from the serial port: data = ser . readline () 8. The serial port object has a method called write() . This method writes data to the serial port. You can use this method to write data to the serial port. You can use the following code to write data to the serial port: ser . write ( b 'Hello World' )","title":"Hints"},{"location":"5-chapter/#exercise","text":"The most important part of real time data display is to keep the display speed the same as the data acquisition speed. If the display speed is slower than the data acquisition speed, you will lose some data points. If the display speed is faster than the data acquisition speed, you will see the same data points multiple times. In this exercise, you will learn how to keep the display speed the same as the data acquisition speed. The display speed in Python_GUI_day5_display.py is much faster than the data acquisition speed (which is manually controlled). Therefore, you see discrete data points other than continuous data. You can force the display speed to be the same as the data acquisition speed by only updating the display when new data is available. The solutions to this exercise can be found in Python_GUI_day5_exercise.py . At this time, the display is updated only when a new data point is sent from the serial port. I also provide the supports for sending multiple data points at the same time seperated by a space. You can tick the Loop checkbox to simulate continuous data acquisition.","title":"Exercise"}]}